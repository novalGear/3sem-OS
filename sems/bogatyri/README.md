# Consensus

33 богатыря садятся в круг и должны определить, кто какую букву произносит. После чего произносят каждый свою букву в слове последовательно.

Общение происходит сообщениями вида broadcast и point to point.

Запрещается иметь дирижера или заранее распределять номера.


Seminar:

Multiplex I/O

имеем несколько каналов между reader и writer:

1) O_NONBLOCK - чередуем read разных каналов в цикле

2) распараллелить read на несколько процессов, которые после "просуммируют" результат для координатора

Пример задачи на сдаче: написать без NONBLOCK передачу сообщений через несколько каналов

3) ## select/poll interface

Есть множество файловых дескрипторов [1, 2, 7, 15, 18]. Хотим прочитать данные из непустого канала / отправить сообщение.
Отправляем это набор дескрипторов в kernel. Наш системный вызов блокирует вызов, если не можем сделать операцию

Для каждого файлового дескриптора сообщаем операцию (тип ожидания). По изменению состояния дескриптора

Т.е. теперь делаем select/poll на два дескриптора и можем делать read/write буз опасения блокировки.

У select/poll есть параметр timeout/

### Интерфейс select:
fdset - битовый массив от 0 до макс. значения файлового дескриптора. Т.е. можно сформировать readset и writeset из масок с нужными файловыми дескрипторами. Возвращает маски с 1 оставленными на файловых дескрипторах, на которых что-то произошло.

Здесь проблема: ядро опрашивает все файловые дескрипторы, однако активными может быть очень небольшое их число.

 ### Интерфейс poll:
  передача массива структур с fd, маской событий. Обратно возвращаются только структуры, соответствующие активным файловым дескриптором.

А здесь новая проблема: в случае очень большого числа активных клиентов очень много данных придется читать - много данных читает/пишет ядро

 ## Новое развитие интерфейса: epoll/kqueue

state: разбиение коммуникации на 2 стадии:
1) setup - add/del fildes
2) getevent интерфейс

Много клиентов - большой setup, но он исполняется единожды. Однако интерфейс имеет возможность получать только 1 event на fildes. Он может не успевать обрабатывать по одному эти события.

low latency, no dynamics

## I/O submit

setup/getevent

В этом интерфейсе можем получать целую пачку event-ов

Однако при read/write многократное копирование: device <-> kernel <-> user. можно делать shared memory между device и kernel (zero-copy), однако между user и kernel - нет.

## I/O uring (user-ring-buf)

то же самое, только теперь в ядро на setup готовится массив буферов для нужных операций read/write - shared between user and kernel. Теперь это один общий буфер для всех.

